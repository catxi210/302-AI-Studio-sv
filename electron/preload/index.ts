import { electronAPI as electrontToolkitAPI } from "@electron-toolkit/preload";
import type {
	BroadcastEventData,
	ShellWindowFullscreenChange,
	ShortcutActionEvent,
	ShortcutKeyPressEvent,
	ShortcutSyncEvent,
	Tab,
	TabDragGhostClear,
	TabDragGhostHover,
	Theme,
} from "@shared/types";
import { contextBridge, ipcRenderer } from "electron";
import { SHELL_WINDOW_FULLSCREEN_CHANGED } from "../main/constants";
import { autoGeneratedServices } from "../main/generated/preload-services";
import { getAdditionalArgv, loadDataFromTempFile } from "../main/utils";

const serverPortStr = getAdditionalArgv("server-port");
const serverPort = serverPortStr ? Number.parseInt(serverPortStr, 10) : 8089;
const initialTheme = getAdditionalArgv("theme") ?? null;

const app = {
	platform: process.platform,
	isDev: process.env.NODE_ENV === "development",
	serverPort,
};

const windowId = getAdditionalArgv("window-id") ?? "";

const tabFilePath = getAdditionalArgv("tab-file") ?? "";
const threadFilePath = getAdditionalArgv("thread-file") ?? "";
const messagesFilePath = getAdditionalArgv("messages-file") ?? "";

const tab = loadDataFromTempFile(tabFilePath) ?? {};
const tabs: Tab[] = []; // tabs are managed by tab service, not needed in preload
const thread = loadDataFromTempFile(threadFilePath) ?? {};
const messages = loadDataFromTempFile(messagesFilePath) ?? {};

// Use `contextBridge` APIs to expose Electron APIs to
// renderer only if context isolation is enabled, otherwise
// just add to the DOM global.
if (process.contextIsolated) {
	try {
		contextBridge.exposeInMainWorld("electron", electrontToolkitAPI);
		contextBridge.exposeInMainWorld("electronAPI", {
			theme: {
				setTheme: (theme: Theme) => ipcRenderer.send("app:theme:setTheme", theme),
				onThemeChange: (callback: (theme: Theme) => void) => {
					ipcRenderer.on("app:theme:setTheme", (_, theme) => callback(theme));
				},
				getCurrentTheme: () => ipcRenderer.invoke("app:theme:getCurrentTheme"),
			},
			shortcut: {
				onShortcutSync: (callback: (data: ShortcutSyncEvent) => void) => {
					const listener = (_: unknown, data: ShortcutSyncEvent) => callback(data);
					ipcRenderer.on("shortcut:sync", listener);
					return () => ipcRenderer.removeListener("shortcut:sync", listener);
				},
				onShortcutAction: (callback: (event: ShortcutActionEvent) => void) => {
					const listener = (_: unknown, event: ShortcutActionEvent) => callback(event);
					ipcRenderer.on("shortcut:action", listener);
					return () => ipcRenderer.removeListener("shortcut:action", listener);
				},
				sendShortcutKeyPressed: (event: ShortcutKeyPressEvent) => {
					ipcRenderer.send("shortcut:key-pressed", event);
				},
			},
			onThemeChange: (callback: (theme: string) => void) => {
				ipcRenderer.on("theme:set", (_, theme) => callback(theme));
			},
			onThreadListUpdate: (callback: () => void) => {
				ipcRenderer.on("broadcast-event", (_, eventData: BroadcastEventData) => {
					if (eventData.broadcastEvent === "thread-list-updated") {
						callback();
					}
				});
			},

			onScreenshotTriggered: (callback: (data: { threadId: string }) => void) => {
				const listener = (_: unknown, eventData: BroadcastEventData) => {
					if (eventData.broadcastEvent === "trigger-screenshot") {
						callback(eventData.data as { threadId: string });
					}
				};
				ipcRenderer.on("broadcast-event", listener);
				return () => ipcRenderer.removeListener("broadcast-event", listener);
			},
			onShowToast: (
				callback: (data: { type: string; message: string; threadId?: string }) => void,
			) => {
				const listener = (_: unknown, eventData: BroadcastEventData) => {
					if (eventData.broadcastEvent === "show-toast") {
						callback(eventData.data as { type: string; message: string; threadId?: string });
					}
				};
				ipcRenderer.on("broadcast-event", listener);
				return () => ipcRenderer.removeListener("broadcast-event", listener);
			},
			onTriggerSendMessage: (callback: (data: { threadId: string }) => void) => {
				const listener = (_: unknown, eventData: BroadcastEventData) => {
					if (eventData.broadcastEvent === "trigger-send-message") {
						callback(eventData.data as { threadId: string });
					}
				};
				ipcRenderer.on("broadcast-event", listener);
				return () => ipcRenderer.removeListener("broadcast-event", listener);
			},
			onCodeAgentSandboxUpdated: (
				callback: (data: { threadId: string; sandboxId: string }) => void,
			) => {
				const listener = (_: unknown, data: { threadId: string; sandboxId: string }) =>
					callback(data);
				ipcRenderer.on("code-agent:sandbox-updated", listener);
				return () => ipcRenderer.removeListener("code-agent:sandbox-updated", listener);
			},
			onSidebarStateChanged: (callback: (data: { open: boolean }) => void) => {
				const listener = (_: unknown, eventData: BroadcastEventData) => {
					if (eventData.broadcastEvent === "sidebar-state-changed") {
						callback(eventData.data as { open: boolean });
					}
				};
				ipcRenderer.on("broadcast-event", listener);
				return () => ipcRenderer.removeListener("broadcast-event", listener);
			},
			onShellWindowFullscreenChange: (callback: (payload: ShellWindowFullscreenChange) => void) => {
				const listener = (_: unknown, payload: ShellWindowFullscreenChange) => callback(payload);
				ipcRenderer.on(SHELL_WINDOW_FULLSCREEN_CHANGED, listener);
				return () => ipcRenderer.removeListener(SHELL_WINDOW_FULLSCREEN_CHANGED, listener);
			},
			onTabDragGhostHover: (callback: (payload: TabDragGhostHover) => void) => {
				const listener = (_: unknown, payload: TabDragGhostHover) => {
					// Only process if this is the target window
					if (payload.windowId === windowId) {
						callback(payload);
					}
				};
				ipcRenderer.on("tab:drag:ghost:hover", listener);
				return () => ipcRenderer.removeListener("tab:drag:ghost:hover", listener);
			},
			onTabDragGhostClear: (callback: (payload: TabDragGhostClear) => void) => {
				const listener = (_: unknown, payload: TabDragGhostClear) => {
					// Only process if this is the target window
					if (payload.windowId === windowId) {
						callback(payload);
					}
				};
				ipcRenderer.on("tab:drag:ghost:clear", listener);
				return () => ipcRenderer.removeListener("tab:drag:ghost:clear", listener);
			},
			onPersistedStateSync: <T>(key: string, callback: (syncValue: T) => void) => {
				const listener = (_: unknown, syncValue: T) => callback(syncValue);
				ipcRenderer.on(key, listener);
				return () => ipcRenderer.removeListener(key, listener);
			},
			updater: {
				onUpdateChecking: (callback: () => void) => {
					const listener = () => callback();
					ipcRenderer.on("updater:update-checking", listener);
					return () => ipcRenderer.removeListener("updater:update-checking", listener);
				},
				onUpdateAvailable: (callback: () => void) => {
					const listener = () => callback();
					ipcRenderer.on("updater:update-available", listener);
					return () => ipcRenderer.removeListener("updater:update-available", listener);
				},
				onUpdateNotAvailable: (callback: () => void) => {
					const listener = () => callback();
					ipcRenderer.on("updater:update-not-available", listener);
					return () => ipcRenderer.removeListener("updater:update-not-available", listener);
				},
				onUpdateDownloaded: (
					callback: (data: { releaseNotes: string; releaseName: string }) => void,
				) => {
					const listener = (_: unknown, data: { releaseNotes: string; releaseName: string }) =>
						callback(data);
					ipcRenderer.on("updater:update-downloaded", listener);
					return () => ipcRenderer.removeListener("updater:update-downloaded", listener);
				},
				onUpdateError: (callback: (data: { message: string }) => void) => {
					const listener = (_: unknown, data: { message: string }) => callback(data);
					ipcRenderer.on("updater:update-error", listener);
					return () => ipcRenderer.removeListener("updater:update-error", listener);
				},
			},
			...autoGeneratedServices,
			onTabClearMessages: (callback: (data: { tabId: string; threadId: string }) => void) => {
				const listener = (_: unknown, data: { tabId: string; threadId: string }) => callback(data);
				ipcRenderer.on("tab:clear-messages", listener);
				return () => ipcRenderer.removeListener("tab:clear-messages", listener);
			},
			onTabGenerateTitle: (callback: (data: { tabId: string; threadId: string }) => void) => {
				const listener = (_: unknown, data: { tabId: string; threadId: string }) => callback(data);
				ipcRenderer.on("tab:generate-title", listener);
				return () => ipcRenderer.removeListener("tab:generate-title", listener);
			},
			onSandboxCreated: (callback: (data: { threadId: string; sandboxId: string }) => void) => {
				const listener = (_: unknown, data: { threadId: string; sandboxId: string }) =>
					callback(data);
				ipcRenderer.on("code-agent:sandbox-created", listener);
				return () => ipcRenderer.removeListener("code-agent:sandbox-created", listener);
			},
			aiApplication: {
				onAiApplicationsLoading: (callback: (loading: boolean) => void) => {
					const listener = (_: unknown, loading: boolean) => callback(loading);
					ipcRenderer.on("ai-applications:loading", listener);
					return () => ipcRenderer.removeListener("ai-applications:loading", listener);
				},
			},
			plugin: {
				onNotification: (
					callback: (data: {
						pluginId: string;
						pluginName: string;
						message: string;
						type: "info" | "success" | "warning" | "error";
					}) => void,
				) => {
					const listener = (
						_: unknown,
						data: {
							pluginId: string;
							pluginName: string;
							message: string;
							type: "info" | "success" | "warning" | "error";
						},
					) => callback(data);
					ipcRenderer.on("plugin:notification", listener);
					return () => ipcRenderer.removeListener("plugin:notification", listener);
				},
			},
		});

		// Expose shell window ID from process arguments
		contextBridge.exposeInMainWorld("windowId", windowId);
		contextBridge.exposeInMainWorld("tab", tab);
		contextBridge.exposeInMainWorld("tabs", tabs);
		contextBridge.exposeInMainWorld("app", app);
		contextBridge.exposeInMainWorld("thread", thread);
		contextBridge.exposeInMainWorld("messages", messages);
		contextBridge.exposeInMainWorld("initialTheme", initialTheme);
	} catch (error) {
		console.error("Preload: Error exposing services", { error });
	}
} else {
	window.app = app;
	window.electron = electrontToolkitAPI;
}
