/* eslint-disable @typescript-eslint/no-explicit-any */
import { ipcRenderer } from "electron";
import type {
	PluginMarketEntry,
	BroadcastEvent,
	StorageValue,
	StorageOptions,
	StorageMetadata,
	StorageMeta,
	StorageItem,
	InstalledPlugin,
	ProviderDefinition,
	PluginSource,
	ModelProvider,
	Model,
	LanguageCode,
	InsertTarget,
	ShortcutBinding,
	ShortcutConflict,
	ShortcutSyncEvent,
	TabType,
	Tab,
	Theme,
	ImportResult,
	BackupInfo,
	McpServer,
	ThreadData,
	UpdateChannel,
} from "@shared/types";

/**
 * Auto-generated IPC service interfaces
 */
export interface AutoGeneratedIpcServices {
	registryService: {
		getMarketplacePlugins(): Promise<PluginMarketEntry[]>;
		getMarketplacePlugin(pluginId: string): Promise<PluginMarketEntry | null>;
		searchMarketplacePlugins(query: string): Promise<PluginMarketEntry[]>;
		getFeaturedPlugins(): Promise<PluginMarketEntry[]>;
		refreshRegistry(): Promise<PluginMarketEntry[]>;
		clearCache(): Promise<void>;
		getCacheInfo(): Promise<{
			valid: boolean;
			age: number;
			pluginCount: number;
			lastUpdated?: string;
		}>;
	};
	broadcastService: {
		broadcastExcludeSource(broadcastEvent: BroadcastEvent, data: any): Promise<void>;
		broadcastToAll(broadcastEvent: BroadcastEvent, data: any): Promise<void>;
	};
	storageService: {
		setItem(key: string, value: StorageValue): Promise<void>;
		getItem(key: string): Promise<StorageValue | null>;
		hasItem(key: string): Promise<boolean>;
		removeItem(key: string, options: StorageOptions): Promise<void>;
		getKeys(base?: string): Promise<string[]>;
		clear(base?: string): Promise<void>;
		getMeta(key: string): Promise<StorageMetadata>;
		setMeta(key: string, metadata: StorageMeta): Promise<void>;
		removeMeta(key: string): Promise<void>;
		getItems(keys: string[]): Promise<StorageItem<StorageValue>[]>;
		setItems(items: StorageItem<StorageValue>[]): Promise<void>;
		watch(watchKey: string): Promise<void>;
		unwatch(watchKey: string): Promise<void>;
	};
	pluginService: {
		getInstalledPlugins(): Promise<InstalledPlugin[]>;
		getPlugin(pluginId: string): Promise<InstalledPlugin | null>;
		getEnabledPlugins(): Promise<InstalledPlugin[]>;
		getProviderPlugins(): Promise<ProviderDefinition[]>;
		enablePlugin(pluginId: string): Promise<void>;
		disablePlugin(pluginId: string): Promise<void>;
		installPlugin(source: PluginSource): Promise<InstalledPlugin>;
		uninstallPlugin(pluginId: string): Promise<void>;
		checkForUpdates(pluginId: string): Promise<{
			hasUpdate: boolean;
			currentVersion: string;
			latestVersion?: string;
			downloadUrl?: string;
		}>;
		updatePlugin(pluginId: string): Promise<void>;
		reloadPlugin(pluginId: string): Promise<void>;
		selectPluginFolder(): Promise<string | null>;
		getPluginConfig(pluginId: string): Promise<Record<string, unknown>>;
		setPluginConfig(pluginId: string, config: Record<string, unknown>): Promise<void>;
		getPluginConfigValue(pluginId: string, key: string): Promise<unknown>;
		setPluginConfigValue(pluginId: string, key: string, value: unknown): Promise<void>;
		fetchModelsFromProvider(provider: ModelProvider): Promise<Model[]>;
		executeBeforeSendMessageHook(context: {
			messages: unknown[];
			userMessage: unknown;
			model: Model;
			provider: ModelProvider;
			parameters: Record<string, unknown>;
			options: Record<string, unknown>;
		}): Promise<{
			messages: unknown[];
			userMessage: unknown;
			model: Model;
			provider: ModelProvider;
			parameters: Record<string, unknown>;
			options: Record<string, unknown>;
		}>;
		executeAfterSendMessageHook(
			context: {
				messages: unknown[];
				userMessage: unknown;
				model: Model;
				provider: ModelProvider;
				parameters: Record<string, unknown>;
				options: Record<string, unknown>;
			},
			response: {
				message: unknown;
				usage?: {
					promptTokens: number;
					completionTokens: number;
					totalTokens: number;
				};
				model: string;
				finishReason: string;
				metadata?: Record<string, unknown>;
			},
		): Promise<void>;
		executeErrorHook(
			errorData: { message: string; stack?: string; name?: string },
			context: {
				source: string;
				provider?: ModelProvider;
				model?: Model;
				metadata?: Record<string, unknown>;
			},
		): Promise<{
			handled: boolean;
			retry?: boolean;
			retryDelay?: number;
			message?: string;
		}>;
	};
	generalSettingsService: {
		handleLanguageChanged(language: LanguageCode): Promise<void>;
	};
	codeAgentService: {
		updateClaudeCodeSandboxModel(
			threadId: string,
			sandbox_id: string,
			llm_model: string,
		): Promise<{ isOK: boolean; llm_model: string }>;
		checkClaudeCodeSandbox(sandboxId: string): Promise<{
			isOK: boolean;
			valid: boolean;
			sandboxInfo?: {
				sandboxId: string;
				sandboxRemark: string;
				llmModel: string;
				diskUsage: "normal" | "insufficient";
			};
		}>;
		updateClaudeCodeSandboxesByIpc(): Promise<{ isOK: boolean }>;
		updateClaudeCodeSessions(sandboxId: string): Promise<{ isOK: boolean }>;
		updateClaudeCodeCurrentSessionIdByThreadId(
			threadId: string,
			sessionId: string,
		): Promise<{ isOK: boolean }>;
		updateClaudeCodeSandboxRemark(
			sandbox_id: string,
			remark: string,
		): Promise<{ isOK: boolean; remark: string }>;
		createClaudeCodeSandboxByIpc(
			threadId: string,
			sandboxName: string,
		): Promise<{ isOK: boolean; sandboxId: string }>;
		deleteClaudeCodeSandboxByIpc(sandbox_id: string): Promise<{ isOK: boolean; error?: string }>;
		deleteClaudeCodeSession(sandbox_id: string, session_id: string): Promise<{ isOK: boolean }>;
		findClaudeCodeSandboxWithValidDisk(threadId: string): Promise<{
			isOK: boolean;
			sandboxInfo?: {
				sandboxId: string;
				sandboxRemark: string;
				llmModel: string;
				diskUsage: "normal" | "insufficient";
			};
		}>;
	};
	ghostWindowService: {
		startTracking(): Promise<void>;
		stopTracking(): Promise<void>;
		updateInsertIndex(target: InsertTarget): Promise<void>;
	};
	windowService: {
		handleOpenSettingsWindow(route?: string): Promise<void>;
		focusWindow(windowId: string, tabId?: string): Promise<void>;
		handleDropAtPointer(
			tabId: string,
			pointer: { screenX: number; screenY: number },
		): Promise<
			| { action: "merged"; targetWindowId: string }
			| { action: "detached"; newWindowId: string }
			| null
		>;
		handleSplitShellWindow(triggerTabId: string): Promise<string | null>;
		handleMoveTabIntoExistingWindow(
			triggerTabId: string,
			windowId: string,
			insertIndex?: number,
		): Promise<void>;
	};
	shortcutService: {
		init(shortcuts: ShortcutBinding[]): Promise<void>;
		updateShortcuts(shortcuts: ShortcutBinding[]): Promise<void>;
		getConflicts(): Promise<ShortcutConflict[]>;
		getSyncInfo(): Promise<ShortcutSyncEvent>;
	};
	tabService: {
		handleNewTabWithThread(
			threadId: string,
			title: string,
			type: TabType,
			active: boolean,
		): Promise<string | null>;
		handleNewTab(
			title: string,
			type: TabType,
			active: boolean,
			href?: string,
			content?: string,
			previewId?: string,
		): Promise<string | null>;
		handleActivateTab(tabId: string): Promise<void>;
		getActiveTab(): Promise<Tab | null>;
		getAllTabsForCurrentWindow(): Promise<Tab[] | null>;
		getAllTabs(): Promise<Tab[] | null>;
		handleTabClose(tabId: string, newActiveTabId: string | null): Promise<void>;
		handleTabCloseOthers(tabId: string, tabIdsToClose: string[]): Promise<void>;
		handleTabCloseOffside(
			tabId: string,
			tabIdsToClose: string[],
			_remainingTabIds: string[],
			shouldSwitchActive: boolean,
		): Promise<void>;
		handleShellViewLevel(up: boolean): Promise<void>;
		replaceTabContent(tabId: string, newThreadId: string): Promise<boolean>;
		handleClearTabMessages(tabId: string, threadId: string): Promise<boolean>;
		handleGenerateTabTitle(tabId: string, threadId: string): Promise<boolean>;
	};
	aiApplicationService: {
		getAiApplicationUrl(applicationId: number): Promise<{
			isOk: boolean;
			url: string;
		}>;
		handle302AIProviderChange(updatedApiKey: string): Promise<void>;
		handleAiApplicationReload(tabId: string): Promise<void>;
	};
	appService: {
		getTheme(): Promise<Theme>;
		setTheme(theme: Theme): Promise<void>;
		restartApp(): Promise<void>;
		resetAllData(): Promise<void>;
		clearChatHistory(): Promise<void>;
	};
	dataService: {
		importLegacyJson(): Promise<ImportResult>;
		exportStorage(): Promise<string | null>;
		importStorage(): Promise<ImportResult>;
		listBackups(): Promise<BackupInfo[]>;
		restoreFromBackup(backupPath: string): Promise<ImportResult>;
		deleteBackup(backupPath: string): Promise<boolean>;
		openBackupDirectory(): Promise<void>;
		checkOldVersionData(): Promise<boolean>;
		zipFolderForUpload(): Promise<{ zipPath: string; folderName: string } | null>;
	};
	externalLinkService: {
		openExternalLink(url: string): Promise<{
			isOk: boolean;
			error?: string;
		}>;
	};
	mcpService: {
		getToolsFromServer(server: McpServer): Promise<{
			isOk: boolean;
			tools?: Array<{
				name: string;
				description?: string;
				inputSchema?: Record<string, unknown>;
			}>;
			error?: string;
		}>;
		closeServer(serverId: string): Promise<{ isOk: boolean; error?: string }>;
	};
	ssoService: {
		openSsoLogin(
			serverPort: number,
			language: string,
		): Promise<{ success: boolean; error?: string }>;
		waitForSsoCallback(
			timeoutMs: number,
		): Promise<{ success: boolean; apiKey?: string; error?: string }>;
		cancelSsoLogin(): void;
	};
	threadService: {
		addThread(threadId: string): Promise<boolean>;
		getThreads(): Promise<ThreadData[] | null>;
		getThread(threadId: string): Promise<ThreadData | null>;
		deleteThread(threadId: string): Promise<boolean>;
		renameThread(threadId: string, newName: string): Promise<boolean>;
		addFavorite(threadId: string): Promise<boolean>;
		removeFavorite(threadId: string): Promise<boolean>;
		deleteThreadsByApiKeyHash(apiKeyHash: string): Promise<number>;
	};
	updaterService: {
		checkForUpdatesManually(): Promise<void>;
		quitAndInstall(): Promise<void>;
		isUpdateDownloaded(): Promise<boolean>;
		setAutoUpdate(enabled: boolean): Promise<void>;
		setUpdateChannel(channel: UpdateChannel): Promise<void>;
		getUpdateChannel(): Promise<UpdateChannel>;
	};
}

/**
 * Auto-generated service implementations
 */
export const autoGeneratedServices: AutoGeneratedIpcServices = {
	registryService: {
		getMarketplacePlugins: () => ipcRenderer.invoke("registryService:getMarketplacePlugins"),
		getMarketplacePlugin: (pluginId: string) =>
			ipcRenderer.invoke("registryService:getMarketplacePlugin", pluginId),
		searchMarketplacePlugins: (query: string) =>
			ipcRenderer.invoke("registryService:searchMarketplacePlugins", query),
		getFeaturedPlugins: () => ipcRenderer.invoke("registryService:getFeaturedPlugins"),
		refreshRegistry: () => ipcRenderer.invoke("registryService:refreshRegistry"),
		clearCache: () => ipcRenderer.invoke("registryService:clearCache"),
		getCacheInfo: () => ipcRenderer.invoke("registryService:getCacheInfo"),
	},
	broadcastService: {
		broadcastExcludeSource: (broadcastEvent: BroadcastEvent, data: any) =>
			ipcRenderer.invoke("broadcastService:broadcastExcludeSource", broadcastEvent, data),
		broadcastToAll: (broadcastEvent: BroadcastEvent, data: any) =>
			ipcRenderer.invoke("broadcastService:broadcastToAll", broadcastEvent, data),
	},
	storageService: {
		setItem: (key: string, value: StorageValue) =>
			ipcRenderer.invoke("storageService:setItem", key, value),
		getItem: (key: string) => ipcRenderer.invoke("storageService:getItem", key),
		hasItem: (key: string) => ipcRenderer.invoke("storageService:hasItem", key),
		removeItem: (key: string, options: StorageOptions) =>
			ipcRenderer.invoke("storageService:removeItem", key, options),
		getKeys: (base?: string) => ipcRenderer.invoke("storageService:getKeys", base),
		clear: (base?: string) => ipcRenderer.invoke("storageService:clear", base),
		getMeta: (key: string) => ipcRenderer.invoke("storageService:getMeta", key),
		setMeta: (key: string, metadata: StorageMeta) =>
			ipcRenderer.invoke("storageService:setMeta", key, metadata),
		removeMeta: (key: string) => ipcRenderer.invoke("storageService:removeMeta", key),
		getItems: (keys: string[]) => ipcRenderer.invoke("storageService:getItems", keys),
		setItems: (items: StorageItem<StorageValue>[]) =>
			ipcRenderer.invoke("storageService:setItems", items),
		watch: (watchKey: string) => ipcRenderer.invoke("storageService:watch", watchKey),
		unwatch: (watchKey: string) => ipcRenderer.invoke("storageService:unwatch", watchKey),
	},
	pluginService: {
		getInstalledPlugins: () => ipcRenderer.invoke("pluginService:getInstalledPlugins"),
		getPlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:getPlugin", pluginId),
		getEnabledPlugins: () => ipcRenderer.invoke("pluginService:getEnabledPlugins"),
		getProviderPlugins: () => ipcRenderer.invoke("pluginService:getProviderPlugins"),
		enablePlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:enablePlugin", pluginId),
		disablePlugin: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:disablePlugin", pluginId),
		installPlugin: (source: PluginSource) =>
			ipcRenderer.invoke("pluginService:installPlugin", source),
		uninstallPlugin: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:uninstallPlugin", pluginId),
		checkForUpdates: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:checkForUpdates", pluginId),
		updatePlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:updatePlugin", pluginId),
		reloadPlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:reloadPlugin", pluginId),
		selectPluginFolder: () => ipcRenderer.invoke("pluginService:selectPluginFolder"),
		getPluginConfig: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:getPluginConfig", pluginId),
		setPluginConfig: (pluginId: string, config: Record<string, unknown>) =>
			ipcRenderer.invoke("pluginService:setPluginConfig", pluginId, config),
		getPluginConfigValue: (pluginId: string, key: string) =>
			ipcRenderer.invoke("pluginService:getPluginConfigValue", pluginId, key),
		setPluginConfigValue: (pluginId: string, key: string, value: unknown) =>
			ipcRenderer.invoke("pluginService:setPluginConfigValue", pluginId, key, value),
		fetchModelsFromProvider: (provider: ModelProvider) =>
			ipcRenderer.invoke("pluginService:fetchModelsFromProvider", provider),
		executeBeforeSendMessageHook: (context: {
			messages: unknown[];
			userMessage: unknown;
			model: Model;
			provider: ModelProvider;
			parameters: Record<string, unknown>;
			options: Record<string, unknown>;
		}) => ipcRenderer.invoke("pluginService:executeBeforeSendMessageHook", context),
		executeAfterSendMessageHook: (
			context: {
				messages: unknown[];
				userMessage: unknown;
				model: Model;
				provider: ModelProvider;
				parameters: Record<string, unknown>;
				options: Record<string, unknown>;
			},
			response: {
				message: unknown;
				usage?: {
					promptTokens: number;
					completionTokens: number;
					totalTokens: number;
				};
				model: string;
				finishReason: string;
				metadata?: Record<string, unknown>;
			},
		) => ipcRenderer.invoke("pluginService:executeAfterSendMessageHook", context, response),
		executeErrorHook: (
			errorData: { message: string; stack?: string; name?: string },
			context: {
				source: string;
				provider?: ModelProvider;
				model?: Model;
				metadata?: Record<string, unknown>;
			},
		) => ipcRenderer.invoke("pluginService:executeErrorHook", errorData, context),
	},
	generalSettingsService: {
		handleLanguageChanged: (language: LanguageCode) =>
			ipcRenderer.invoke("generalSettingsService:handleLanguageChanged", language),
	},
	codeAgentService: {
		updateClaudeCodeSandboxModel: (threadId: string, sandbox_id: string, llm_model: string) =>
			ipcRenderer.invoke(
				"codeAgentService:updateClaudeCodeSandboxModel",
				threadId,
				sandbox_id,
				llm_model,
			),
		checkClaudeCodeSandbox: (sandboxId: string) =>
			ipcRenderer.invoke("codeAgentService:checkClaudeCodeSandbox", sandboxId),
		updateClaudeCodeSandboxesByIpc: () =>
			ipcRenderer.invoke("codeAgentService:updateClaudeCodeSandboxesByIpc"),
		updateClaudeCodeSessions: (sandboxId: string) =>
			ipcRenderer.invoke("codeAgentService:updateClaudeCodeSessions", sandboxId),
		updateClaudeCodeCurrentSessionIdByThreadId: (threadId: string, sessionId: string) =>
			ipcRenderer.invoke(
				"codeAgentService:updateClaudeCodeCurrentSessionIdByThreadId",
				threadId,
				sessionId,
			),
		updateClaudeCodeSandboxRemark: (sandbox_id: string, remark: string) =>
			ipcRenderer.invoke("codeAgentService:updateClaudeCodeSandboxRemark", sandbox_id, remark),
		createClaudeCodeSandboxByIpc: (threadId: string, sandboxName: string) =>
			ipcRenderer.invoke("codeAgentService:createClaudeCodeSandboxByIpc", threadId, sandboxName),
		deleteClaudeCodeSandboxByIpc: (sandbox_id: string) =>
			ipcRenderer.invoke("codeAgentService:deleteClaudeCodeSandboxByIpc", sandbox_id),
		deleteClaudeCodeSession: (sandbox_id: string, session_id: string) =>
			ipcRenderer.invoke("codeAgentService:deleteClaudeCodeSession", sandbox_id, session_id),
		findClaudeCodeSandboxWithValidDisk: (threadId: string) =>
			ipcRenderer.invoke("codeAgentService:findClaudeCodeSandboxWithValidDisk", threadId),
	},
	ghostWindowService: {
		startTracking: () => ipcRenderer.invoke("ghostWindowService:startTracking"),
		stopTracking: () => ipcRenderer.invoke("ghostWindowService:stopTracking"),
		updateInsertIndex: (target: InsertTarget) =>
			ipcRenderer.invoke("ghostWindowService:updateInsertIndex", target),
	},
	windowService: {
		handleOpenSettingsWindow: (route?: string) =>
			ipcRenderer.invoke("windowService:handleOpenSettingsWindow", route),
		focusWindow: (windowId: string, tabId?: string) =>
			ipcRenderer.invoke("windowService:focusWindow", windowId, tabId),
		handleDropAtPointer: (tabId: string, pointer: { screenX: number; screenY: number }) =>
			ipcRenderer.invoke("windowService:handleDropAtPointer", tabId, pointer),
		handleSplitShellWindow: (triggerTabId: string) =>
			ipcRenderer.invoke("windowService:handleSplitShellWindow", triggerTabId),
		handleMoveTabIntoExistingWindow: (
			triggerTabId: string,
			windowId: string,
			insertIndex?: number,
		) =>
			ipcRenderer.invoke(
				"windowService:handleMoveTabIntoExistingWindow",
				triggerTabId,
				windowId,
				insertIndex,
			),
	},
	shortcutService: {
		init: (shortcuts: ShortcutBinding[]) => ipcRenderer.invoke("shortcutService:init", shortcuts),
		updateShortcuts: (shortcuts: ShortcutBinding[]) =>
			ipcRenderer.invoke("shortcutService:updateShortcuts", shortcuts),
		getConflicts: () => ipcRenderer.invoke("shortcutService:getConflicts"),
		getSyncInfo: () => ipcRenderer.invoke("shortcutService:getSyncInfo"),
	},
	tabService: {
		handleNewTabWithThread: (threadId: string, title: string, type: TabType, active: boolean) =>
			ipcRenderer.invoke("tabService:handleNewTabWithThread", threadId, title, type, active),
		handleNewTab: (
			title: string,
			type: TabType,
			active: boolean,
			href?: string,
			content?: string,
			previewId?: string,
		) =>
			ipcRenderer.invoke("tabService:handleNewTab", title, type, active, href, content, previewId),
		handleActivateTab: (tabId: string) => ipcRenderer.invoke("tabService:handleActivateTab", tabId),
		getActiveTab: () => ipcRenderer.invoke("tabService:getActiveTab"),
		getAllTabsForCurrentWindow: () => ipcRenderer.invoke("tabService:getAllTabsForCurrentWindow"),
		getAllTabs: () => ipcRenderer.invoke("tabService:getAllTabs"),
		handleTabClose: (tabId: string, newActiveTabId: string | null) =>
			ipcRenderer.invoke("tabService:handleTabClose", tabId, newActiveTabId),
		handleTabCloseOthers: (tabId: string, tabIdsToClose: string[]) =>
			ipcRenderer.invoke("tabService:handleTabCloseOthers", tabId, tabIdsToClose),
		handleTabCloseOffside: (
			tabId: string,
			tabIdsToClose: string[],
			_remainingTabIds: string[],
			shouldSwitchActive: boolean,
		) =>
			ipcRenderer.invoke(
				"tabService:handleTabCloseOffside",
				tabId,
				tabIdsToClose,
				_remainingTabIds,
				shouldSwitchActive,
			),
		handleShellViewLevel: (up: boolean) =>
			ipcRenderer.invoke("tabService:handleShellViewLevel", up),
		replaceTabContent: (tabId: string, newThreadId: string) =>
			ipcRenderer.invoke("tabService:replaceTabContent", tabId, newThreadId),
		handleClearTabMessages: (tabId: string, threadId: string) =>
			ipcRenderer.invoke("tabService:handleClearTabMessages", tabId, threadId),
		handleGenerateTabTitle: (tabId: string, threadId: string) =>
			ipcRenderer.invoke("tabService:handleGenerateTabTitle", tabId, threadId),
	},
	aiApplicationService: {
		getAiApplicationUrl: (applicationId: number) =>
			ipcRenderer.invoke("aiApplicationService:getAiApplicationUrl", applicationId),
		handle302AIProviderChange: (updatedApiKey: string) =>
			ipcRenderer.invoke("aiApplicationService:handle302AIProviderChange", updatedApiKey),
		handleAiApplicationReload: (tabId: string) =>
			ipcRenderer.invoke("aiApplicationService:handleAiApplicationReload", tabId),
	},
	appService: {
		getTheme: () => ipcRenderer.invoke("appService:getTheme"),
		setTheme: (theme: Theme) => ipcRenderer.invoke("appService:setTheme", theme),
		restartApp: () => ipcRenderer.invoke("appService:restartApp"),
		resetAllData: () => ipcRenderer.invoke("appService:resetAllData"),
		clearChatHistory: () => ipcRenderer.invoke("appService:clearChatHistory"),
	},
	dataService: {
		importLegacyJson: () => ipcRenderer.invoke("dataService:importLegacyJson"),
		exportStorage: () => ipcRenderer.invoke("dataService:exportStorage"),
		importStorage: () => ipcRenderer.invoke("dataService:importStorage"),
		listBackups: () => ipcRenderer.invoke("dataService:listBackups"),
		restoreFromBackup: (backupPath: string) =>
			ipcRenderer.invoke("dataService:restoreFromBackup", backupPath),
		deleteBackup: (backupPath: string) =>
			ipcRenderer.invoke("dataService:deleteBackup", backupPath),
		openBackupDirectory: () => ipcRenderer.invoke("dataService:openBackupDirectory"),
		checkOldVersionData: () => ipcRenderer.invoke("dataService:checkOldVersionData"),
		zipFolderForUpload: () => ipcRenderer.invoke("dataService:zipFolderForUpload"),
	},
	externalLinkService: {
		openExternalLink: (url: string) =>
			ipcRenderer.invoke("externalLinkService:openExternalLink", url),
	},
	mcpService: {
		getToolsFromServer: (server: McpServer) =>
			ipcRenderer.invoke("mcpService:getToolsFromServer", server),
		closeServer: (serverId: string) => ipcRenderer.invoke("mcpService:closeServer", serverId),
	},
	ssoService: {
		openSsoLogin: (serverPort: number, language: string) =>
			ipcRenderer.invoke("ssoService:openSsoLogin", serverPort, language),
		waitForSsoCallback: (timeoutMs: number) =>
			ipcRenderer.invoke("ssoService:waitForSsoCallback", timeoutMs),
		cancelSsoLogin: () => ipcRenderer.invoke("ssoService:cancelSsoLogin"),
	},
	threadService: {
		addThread: (threadId: string) => ipcRenderer.invoke("threadService:addThread", threadId),
		getThreads: () => ipcRenderer.invoke("threadService:getThreads"),
		getThread: (threadId: string) => ipcRenderer.invoke("threadService:getThread", threadId),
		deleteThread: (threadId: string) => ipcRenderer.invoke("threadService:deleteThread", threadId),
		renameThread: (threadId: string, newName: string) =>
			ipcRenderer.invoke("threadService:renameThread", threadId, newName),
		addFavorite: (threadId: string) => ipcRenderer.invoke("threadService:addFavorite", threadId),
		removeFavorite: (threadId: string) =>
			ipcRenderer.invoke("threadService:removeFavorite", threadId),
		deleteThreadsByApiKeyHash: (apiKeyHash: string) =>
			ipcRenderer.invoke("threadService:deleteThreadsByApiKeyHash", apiKeyHash),
	},
	updaterService: {
		checkForUpdatesManually: () => ipcRenderer.invoke("updaterService:checkForUpdatesManually"),
		quitAndInstall: () => ipcRenderer.invoke("updaterService:quitAndInstall"),
		isUpdateDownloaded: () => ipcRenderer.invoke("updaterService:isUpdateDownloaded"),
		setAutoUpdate: (enabled: boolean) =>
			ipcRenderer.invoke("updaterService:setAutoUpdate", enabled),
		setUpdateChannel: (channel: UpdateChannel) =>
			ipcRenderer.invoke("updaterService:setUpdateChannel", channel),
		getUpdateChannel: () => ipcRenderer.invoke("updaterService:getUpdateChannel"),
	},
};

/**
 * Export type declaration extensions
 */
export interface ElectronAPIExtension {
	registryService: AutoGeneratedIpcServices["registryService"];
	broadcastService: AutoGeneratedIpcServices["broadcastService"];
	storageService: AutoGeneratedIpcServices["storageService"];
	pluginService: AutoGeneratedIpcServices["pluginService"];
	generalSettingsService: AutoGeneratedIpcServices["generalSettingsService"];
	codeAgentService: AutoGeneratedIpcServices["codeAgentService"];
	ghostWindowService: AutoGeneratedIpcServices["ghostWindowService"];
	windowService: AutoGeneratedIpcServices["windowService"];
	shortcutService: AutoGeneratedIpcServices["shortcutService"];
	tabService: AutoGeneratedIpcServices["tabService"];
	aiApplicationService: AutoGeneratedIpcServices["aiApplicationService"];
	appService: AutoGeneratedIpcServices["appService"];
	dataService: AutoGeneratedIpcServices["dataService"];
	externalLinkService: AutoGeneratedIpcServices["externalLinkService"];
	mcpService: AutoGeneratedIpcServices["mcpService"];
	ssoService: AutoGeneratedIpcServices["ssoService"];
	threadService: AutoGeneratedIpcServices["threadService"];
	updaterService: AutoGeneratedIpcServices["updaterService"];
}
